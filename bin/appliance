#!/usr/bin/env python
import os
import sys
import asyncio
import argparse
import textwrap
import signal
import re
import yaml
from configobj import ConfigObj
from enum import Enum
from typing import NamedTuple, Optional, Tuple
from abc import ABC, abstractmethod
import curses
import _curses
from setproctitle import setproctitle
from aiohttp import ClientSession


__version__ = '0.1.0'


_FIND_INFRASONAR = 'docker compose ls'

_RE_DOCKER_VERSION = \
    re.compile(r'Docker version ([0-9]+)\.([0-9]+)\.([0-9]+).*')
_RE_COMPOSE_PATH = \
    re.compile(r'infrasonar\s+([a-z]+).*\s+(\/.*)docker\-compose\.yml')
_MIN_DOCKER_VERSION = 24


def read_docker_version(output):
    m = _RE_DOCKER_VERSION.match(output)
    if not m:
        return
    try:
        major, minor, patch = int(m.group(1)), int(m.group(2)), int(m.group(3))
    except Exception:
        return
    return major, minor, patch

TOKEN_CHARS = set([ord(c) for c in '0123456789abcdef'])
TOKEN_LEN = 32

class DockerNotFound(Exception):
    install_url = 'https://docs.docker.com/engine/install'


class DockerNoVersion(Exception):
    pass


class DockerVersionTooOld(Exception):
    pass


class InfraSonarNotRunning(Exception):
    pass


class Step(Enum):
    Init = 0
    Main = 1
    Apply = 2


class State:
    loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()
    probes_config_meta_url: str = \
        'https://github.com/infrasonar/manage-/blob/main/probes-config-meta.yml'
    api_url: str
    hub_host: str
    step: Step = Step.Init
    status: Optional[str] = None
    compose_path: Optional[str] = None
    compose_data: Optional[dict] = None
    agentcore_token: Optional[str] = None
    agent_token: Optional[str] = None
    agentcore_zone_id: Optional[int] = None

    @classmethod
    def write(cls):
        try:
            fn = os.path.join(cls.compose_path, '.env')
            conf = ConfigObj()
            conf.filename = fn
            conf['AGENTCORE_TOKEN'] = cls.agentcore_token
            conf['AGENT_TOKEN'] = cls.agent_token
            conf['AGENTCORE_ZONE_ID'] = cls.agentcore_zone_id
            conf.write()
        except Exception as e:
            msg = str(e) or type(e).__name__
            raise Exception(f'failed to write {fn} ({msg})')

        try:
            fn = os.path.join(cls.compose_path, 'docker-compose.yml')
            with open(fn, 'w') as fp:
                yaml.safe_dump(cls.compose_data, fp)
        except Exception as e:
            msg = str(e) or type(e).__name__
            raise Exception(f'failed to write {fn} ({msg})')

    @classmethod
    def read_infrasonar_status(cls, out: str):
        for line in out.splitlines():
            m = _RE_COMPOSE_PATH.match(line)
            if m:
                cls.status = m.group(1)
                cls.compose_path = m.group(2)
                break
        else:
            curdir = os.path.realpath(os.path.curdir)
            for p in (curdir, '/etc/infrasonar'):
                fn = os.path.join(p, 'docker-compose.yml')
                if os.path.exists(fn):
                    try:
                        with open(fn, 'r') as fp:
                            data = yaml.safe_load(fp)
                        assert data['services']['agentcore']
                    except Exception:
                        pass
                    else:
                        cls.compose_path = p
                        cls.status = 'not running'
                        break
                else:
                    cls.status = 'not found'
        if cls.compose_path:
            fn = os.path.join(cls.compose_path, 'docker-compose.yml')
            try:
                with open(fn, 'r') as fp:
                    compose_data = yaml.safe_load(fp)
            except Exception as e:
                msg = str(e) or type(e).__name__
                cls.status = f'broken compose file ({msg})'
            else:
                cls.compose_data = compose_data
            fn = os.path.join(cls.compose_path, '.env')
            try:
                conf = ConfigObj(fn)
                cls.agentcore_token = conf['AGENTCORE_TOKEN']
                cls.agent_token = conf['AGENT_TOKEN']
                cls.agentcore_zone_id = int(conf['AGENTCORE_ZONE_ID'])
            except Exception as e:
                msg = str(e) or type(e).__name__
                cls.status = f'broken .env file ({fn}: {msg})'

    @classmethod
    async def read_probes_config_meta(cls):
        try:
            async with ClientSession() as session:
                async with session.get(State.api_url, ssl=True) as r:
                    r.raise_for_status()


class Pos(NamedTuple):
    y: int
    x: int


class MenuItem(NamedTuple):
    name: str
    func: callable


class Menu:
    def __init__(self, win, pos: Pos, items: Tuple[Optional[MenuItem]],
                 horizontal: bool = False):
        assert isinstance(items[0], MenuItem), 'first must be a MenuItem'
        assert isinstance(items[-1], MenuItem), 'last must be a MenuItem'
        self.win = win
        self.pos = pos
        self.idx = 0
        self.items = items
        self.horizontal = horizontal
        self.draw()

    def draw(self):
        for idx, item in enumerate(self.items):
            if item is None:
                continue
            mode = curses.A_REVERSE if idx == self.idx else curses.A_NORMAL
            if self.horizontal:
                y = self.pos.y
                x = self.pos.x + sum([
                    len(item.name) + 1
                    for item in self.items[:idx]
                    if item is not None])
            else:
                y, x = self.pos.y+idx, self.pos.x
            self.win.addstr(y, x, item.name, mode)
        self.win.refresh()

    def handle_char(self, char: int):
        if char == curses.KEY_UP or char == curses.KEY_LEFT:
            self.idx -= 1
            if self.idx < 0:
                self.idx = len(self.items)-1
        elif char == curses.KEY_DOWN or char == curses.KEY_RIGHT or char == 9:
            self.idx += 1
            if self.idx == len(self.items):
                self.idx = 0
        elif char == curses.KEY_ENTER or char == 10 or char == 13:
            self.items[self.idx].func()

        if self.items[self.idx] is None:
            self.handle_char(char)
        else:
            self.draw()


class Input:
    def __init__(self, pos: Pos, text: str):
        self.pos = pos
        self.text = text

    def draw(self):
        pass


class TokenDialog:
    def __init__(self, stdscr, title: str, token: str,
                 confirm: callable, cancel: callable):
        self.stdscr = stdscr
        self.title = title
        self.hide = True
        self.token = token
        self.curs_x = len(self.token)
        self.confirm = confirm
        self.cancel = cancel
        self.draw()

    async def set_cursor(self):
        curses.setsyx(self.wpos.y + 4, self.wpos.x + 2 + self.curs_x)
        curses.doupdate()

    def draw(self):
        maxy, maxx = self.stdscr.getmaxyx()
        h, w = 9, 60

        curses.curs_set(2)

        self.wpos = Pos(maxy//2-h//2, maxx//2-w//2)
        self.win = self.stdscr.subwin(h, w, self.wpos.y, self.wpos.x)
        self.win.bkgd(' ', curses.color_pair(3) | curses.A_BOLD)
        self.win.erase()
        self.win.box()
        self.win.addstr(2, 2, self.title)
        self.win.addstr(7, 22, '(CTRL+h to show/hide, ESC to cancel)')

        tokenstr = '*' * len(self.token) if self.hide else self.token
        tokenstr = tokenstr.ljust(40)
        self.win.addstr(4, 2, tokenstr, curses.A_REVERSE)
        self.win.refresh()
        asyncio.ensure_future(self.set_cursor())

    def handle_char(self, char: int):
        if char == curses.KEY_LEFT:
            if self.curs_x:
                self.curs_x -= 1
        elif char == curses.KEY_RIGHT:
            if self.curs_x < len(self.token):
                self.curs_x += 1
        elif char == curses.KEY_HOME:
            self.curs_x = 0
        elif char == curses.KEY_END:
            self.curs_x = len(self.token)
        elif char == 263:  # CTRL+h
            self.hide = not self.hide
        elif char in TOKEN_CHARS:
            if len(self.token) < TOKEN_LEN:
                self.token = (
                    self.token[:self.curs_x] +
                    chr(char) +
                    self.token[self.curs_x:])
                self.curs_x += 1
        elif char == curses.KEY_BACKSPACE or char == 127:
            if self.curs_x:
                self.token = \
                    self.token[:self.curs_x-1] + self.token[self.curs_x:]
                self.curs_x -= 1
        elif char == 330:  # DELETE
            self.token = \
                    self.token[:self.curs_x] + self.token[self.curs_x+1:]
        elif char == curses.KEY_ENTER or char == 10 or char == 13:
            if len(self.token) == TOKEN_LEN:
                self.confirm(self.token)
                return
        elif char == 27:  # ESCAPE
            self.cancel()
            return
        self.draw()

class Confirm:
    def __init__(self, stdscr, msg: str, confirm: callable, cancel: callable):
        self.stdscr = stdscr
        self.msg = msg
        self.confirm = confirm
        self.cancel = cancel
        self.draw()

    def draw(self):
        maxy, maxx = self.stdscr.getmaxyx()
        width = min(maxx - 10, 120)
        lines = textwrap.wrap(self.msg, width=width-8)
        h, w = len(lines) + 6, width
        self.win = self.stdscr.subwin(h, w, maxy//2-h//2, maxx//2-w//2)
        self.win.bkgd(' ', curses.color_pair(3) | curses.A_BOLD)
        self.win.erase()
        self.win.box()
        for n, s in enumerate(lines):
            self.win.addstr(n+2, 4, s)

        self.menu = Menu(self.win, Pos(4, 4), (
            MenuItem(' No ', self.cancel),
            MenuItem(' Yes ', self.confirm),
        ), horizontal=True)


class Fatal:
    def __init__(self, stdscr, msg: str, suggestion: Optional[str] = None):
        self.stdscr = stdscr
        self.msg = msg
        self.suggestion = suggestion
        self.draw()

    def draw(self):
        maxy, maxx = self.stdscr.getmaxyx()
        width = min(maxx - 10, 120)
        lines = textwrap.wrap(self.msg, width=width-8)
        if self.suggestion:
            lines.append('')
            lines.extend(textwrap.wrap(self.suggestion, width=width-8))
        lines.append('')
        lines.append("Press 'q' to quit")
        h, w = len(lines) + 4, width
        win = self.stdscr.subwin(h, w, maxy//2-h//2, maxx//2-w//2)
        win.bkgd(' ', curses.color_pair(2) | curses.A_BOLD)
        win.erase()
        win.box()
        for n, s in enumerate(lines):
            win.addstr(n+2, 4, s)
        win.refresh()


class InfraSonarDisplay:
    def __init__(self, stdscr: "_curses._CursesWindow"):
        self.stdscr = stdscr
        self.confirm: Optional[Confirm] = None
        self.token_dialog: Optional[TokenDialog] = None
        self.fatal: Optional[Fatal] = None
        self.menu: Optional[Menu] = None
        self.apply_step = 1
        self.done: bool = False
        self.has_changes = False
        self._spin: Optional(Pos) = None

    async def _spinner(self):
        spinner = '◐◓◑◒'  # '▁▂▃▄▅▆▇█▇▆▅▄▃'
        idx = 0
        while self._spin:
            self.stdscr.addstr(
                self._spin.y,
                self._spin.x,
                spinner[idx % len(spinner)])
            idx += 1
            await asyncio.sleep(0.1)

    def start_spinner(self, y: int, x: int):
        disabled = self._spin is None
        self._spin = Pos(y, x)
        if disabled:
            asyncio.ensure_future(self._spinner())

    def stop_spinner(self):
        self._spin = None

    def set_exit(self) -> None:
        self.done = True

    async def run(self) -> None:
        curses.curs_set(0)
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_RED)
        curses.init_pair(3, curses.COLOR_WHITE, curses.COLOR_CYAN)
        self.stdscr.nodelay(True)
        self.stdscr.bkgd(' ', curses.color_pair(1) | curses.A_BOLD)
        self.make_display()

        while not self.done:
            char = self.stdscr.getch()
            if char == curses.ERR:
                await asyncio.sleep(0.1)
            elif char == curses.KEY_RESIZE:
                self.make_display()
            else:
                self.handle_char(char)

    def fatal_error(self, msg: str, suggestion: Optional[str] = None):
        self.fatal = Fatal(self.stdscr, msg, suggestion)

    async def check_root(self):
        y = 6
        self.stdscr.addstr(y, 4, "Check Root access........................")
        self.start_spinner(y, 45)
        try:
            assert os.geteuid() == 0, \
                'The InfraSonar appliance tool must run as root!!'
            await asyncio.sleep(0.1)
        except Exception as e:
            msg = str(e) or type(e).__name__
            self.fatal_error(msg, "Please start the tool again as root.")
        else:
            self.stdscr.addstr(y, 45, 'OK')
            await self.check_internet()
        finally:
            self.stop_spinner()

    async def check_internet(self):
        y = 7
        self.stdscr.addstr(y, 4, "Check Internet connection................")
        self.start_spinner(y, 45)
        try:
            async with ClientSession() as session:
                async with session.get(State.api_url, ssl=True) as r:
                    r.raise_for_status()
        except Exception as e:
            msg = str(e) or type(e).__name__
            msg = f"Failed to connect to: {State.api_url} (Error: {msg})"
            self.fatal_error(msg, "Please check your network configuration.")
        else:
            self.stdscr.addstr(y, 45, 'OK')
            await self.check_docker_installation()
        finally:
            self.stop_spinner()

    async def check_docker_installation(self):
        y = 8
        self.stdscr.addstr(y, 4, "Check Docker installation................")
        self.start_spinner(y, 45)
        try:
            cmd = 'docker -v'
            proc = await asyncio.create_subprocess_shell(
                cmd,
                stderr=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await proc.communicate()
            out = stdout.decode()
            err = stderr.decode()
            if 'not found' in err or 'not found' in out:
                raise DockerNotFound()
            if err:
                raise Exception(err)
            docker_version = read_docker_version(out)
            if not docker_version:
                raise DockerNoVersion()
            if docker_version[0] < _MIN_DOCKER_VERSION:
                raise DockerVersionTooOld(
                    '.'.join([str(i) for i in docker_version]))
        except DockerNotFound:
            self.fatal_error(
                'Docker is not found on your system.',
                f'Please install docker, see: {DockerNotFound.install_url}')
        except DockerNoVersion:
            self.fatal_error('Failed to read the docker version.')
        except DockerVersionTooOld as e:
            self.fatal_error(
                f'Docker version too old: {e}', 'Please upgrade docker.')
        except Exception as e:
            msg = str(e) or type(e).__name__
            self.fatal_error(f'Unexpected error: {msg}')
        else:
            self.stdscr.addstr(y, 45, 'OK')
            await self.check_infrasonar_installation()
        finally:
            self.stop_spinner()

    async def check_infrasonar_installation(self):
        y = 9
        self.stdscr.addstr(y, 4, "Check InfraSonar appliance status........")
        self.start_spinner(y, 45)
        try:
            cmd = 'docker compose ls'
            proc = await asyncio.create_subprocess_shell(
                cmd,
                stderr=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await proc.communicate()
            out = stdout.decode()
            err = stderr.decode()
            if err:
                raise Exception(err)
            State.read_infrasonar_status(out)
            if State.status != 'running':
                raise InfraSonarNotRunning()
        except InfraSonarNotRunning:
            self.fatal_error(f'InfraSonar status: {State.status}')
        except Exception as e:
            msg = str(e) or type(e).__name__
            self.fatal_error(f'Unexpected error: {msg}')
        else:
            self.stdscr.addstr(y, 45, 'OK')
            await asyncio.sleep(0.2)
            self.to_main()

        finally:
            self.stop_spinner()

    async def test_panel(self):
        panel = curses.panel.new_panel(self.stdscr)

    def set_agentcore_token(self, token):
        if token != State.agentcore_token:
            State.agentcore_token = token
            self.has_changes = True
            self.menu = None
        self.to_main()

    def set_agent_token(self, token):
        if token != State.agent_token:
            State.agent_token = token
            self.has_changes = True
            self.menu = None
        self.to_main()

    def to_main(self):
        self.confirm: Optional[Confirm] = None
        self.token_dialog: Optional[TokenDialog] = None
        self.apply_step = None
        curses.curs_set(0)
        State.step = Step.Main
        asyncio.ensure_future(self.async_make_display())

    async def async_make_display(self):
        self.make_display()

    def on_exit_without_saving(self):
        self.confirm = Confirm(
            self.stdscr,
            'Do you want to quit without saving?',
            self.set_exit,
            self.to_main)

    def on_change_agentcore_token(self):
        self.token_dialog = TokenDialog(
            self.stdscr,
            'Agentcore token',
            State.agentcore_token,
            self.set_agentcore_token,
            self.to_main)

    def on_change_agent_token(self):
        self.token_dialog = TokenDialog(
            self.stdscr,
            'Agent token',
            State.agent_token,
            self.set_agent_token,
            self.to_main)

    def on_change_zone(self):

    async def write_to_disk(self):
        try:
            State.write()
        except Exception as e:
            return self.fatal_error(str(e))
        await asyncio.sleep(0.3)
        self.apply_step += 1
        self.draw_apply()
        await self.docker_compose_pull()

    async def docker_compose_pull(self):
        try:
            cmd = 'docker compose pull'
            proc = await asyncio.create_subprocess_shell(
                cmd,
                stderr=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await proc.communicate()
            out = stdout.decode()
            err = stderr.decode()
        except Exception as e:
            return self.fatal_error(str(e))
        self.apply_step += 1
        self.draw_apply()
        await self.docker_compose_up()

    async def docker_compose_up(self):
        try:
            cmd = 'docker compose up -d'
            proc = await asyncio.create_subprocess_shell(
                cmd,
                stderr=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await proc.communicate()
            out = stdout.decode()
            err = stderr.decode()
        except Exception as e:
            return self.fatal_error(str(e))
        self.apply_step += 1
        self.draw_apply()

    def save_and_apply_changes(self):
        self.apply_step = 1
        State.step = Step.Apply
        self.menu: Optional[Menu] = None
        asyncio.ensure_future(self.async_make_display())
        asyncio.ensure_future(self.write_to_disk())

    def draw_apply(self):
        y, x = 7, 33
        self.stdscr.addstr(
            y, 4, "(Each step might take several minutes, please be patient!)")

        y += 2
        self.stdscr.addstr(y, 4, "write changes to disk........")
        if self.apply_step > 1:
            self.stdscr.addstr(y, x, "OK")
            y += 1
            self.stdscr.addstr(y, 4, "docker compose pull..........")
        if self.apply_step > 2:
            self.stdscr.addstr(y, x, "OK")
            y += 1
            self.stdscr.addstr(y, 4, "docker compose up............")

        if self.apply_step > 3:
            self.stdscr.addstr(y, x, "OK")
            y += 2
            self.stdscr.addstr(y, 4, "Done! (press any key to continue)")
            self.stop_spinner()
            self.has_changes = False
        else:
            self.start_spinner(y, x)

    def on_init(self):
        maxy, maxx = self.stdscr.getmaxyx()
        self.stdscr.addstr(maxy - 2, maxx - 20, "Press 'q' to quit")
        self.stdscr.refresh()

        if self.fatal:
            self.fatal.draw()
        else:
            for signame in ('SIGINT', 'SIGTERM'):
                State.loop.add_signal_handler(
                    getattr(signal, signame), self.set_exit)

            asyncio.ensure_future(self.check_root())

    def on_main(self):
        maxy, maxx = self.stdscr.getmaxyx()
        msg = f"InfraSonar status: {State.status}"
        self.stdscr.addstr(maxy - 2, maxx - len(msg) - 2, msg)
        self.stdscr.refresh()

        if self.menu:
            self.menu.draw()
        else:
            items = [
                MenuItem(
                    'Change agentcore token  ',
                    self.on_change_agentcore_token),
                MenuItem(
                    'Change agent token      ',
                    self.on_change_agent_token),
                MenuItem('Change zone             ', lambda: None),
                None,
            ]
            if self.has_changes:
                items.extend([
                    MenuItem(
                        'Save and apply changes  ',
                        self.save_and_apply_changes),
                    MenuItem(
                        'Exit without saving     ',
                        self.on_exit_without_saving),
                ])
            else:
                items.append(
                    MenuItem('Exit                    ', self.set_exit)
                )


            self.menu = Menu(self.stdscr, Pos(6, 4), items, horizontal=False)

        if self.confirm:
            self.confirm.draw()

        if self.token_dialog:
            self.token_dialog.draw()

    def make_display(self) -> None:
        self.stdscr.erase()
        self.stdscr.addstr(1, 1, r"""    ___       __          ___
    |_ _|_ _  / _|_ _ __ _/ __| ___ _ _  __ _ _ _
     | || ' \|  _| '_/ _` \__ \/ _ \ ' \/ _` | '_|
    |___|_||_|_| |_| \__,_|___/\___/_||_\__,_|_|
""")

        self.stdscr.box()

        if State.step is Step.Init:
            self.on_init()
        elif State.step is Step.Main:
            self.on_main()
        elif State.step is Step.Apply:
            self.draw_apply()

    def handle_char(self, char: int) -> None:
        if self.token_dialog:
            self.token_dialog.handle_char(char)
        elif self.confirm:
            self.confirm.menu.handle_char(char)
        elif State.step is Step.Init or (
                State.step is Step.Apply and self.fatal):
            if chr(char) == 'q':
                self.set_exit()
        elif State.step is Step.Apply and self.apply_step > 3:
            self.to_main()
        elif State.step is Step.Main:
            self.menu.handle_char(char)


async def display_main(stdscr):
    disp = InfraSonarDisplay(stdscr)
    await disp.run()


def main(stdscr) -> None:
    loop = asyncio.get_event_loop()
    # add signal handlers
    return State.loop.run_until_complete(display_main(stdscr))


if __name__ == "__main__":
    setproctitle('appliance-toolkit')

    parser = argparse.ArgumentParser(prog='appliance-toolkit')
    parser.add_argument(
        '--version', '-v',
        action='store_true',
        help='Show version and exit')
    parser.add_argument(
        '--development',
        action='store_true',
        help='Use the InfraSonar development environment')

    args = parser.parse_args()

    if args.version:
        print(f'InfraSonar appliance toolkit version {__version__}')
        sys.exit(0)

    if args.development:
        State.api_url = 'https://devapi.infrasonar.com'
        State.hub_host = 'devhub.infrasonar.com'
    else:
        State.api_url = 'https://api.infrasonar.com'
        State.hub_host = 'hub.infrasonar.com'

    curses.wrapper(main)
